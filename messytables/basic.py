from datetime import datetime

from messytables.util import skip_n, \
        STRING, INTEGER, FLOAT, DECIMAL, \
        DATE
from messytables.guesser import type_guess

class Cell(object):

    def __init__(self, value, column=None, type=STRING):
        self.value = value
        self.column = column
        self.column_autogenerated = False
        self.type = type
        self.format = None

    def __repr__(self):
        if self.column is not None:
            return "<Cell(%s=%s:%s>" % (self.column, 
                    self.type.__name__, self.value)
        return "<Cell(%s:%s>" % (self.type.__name__, self.value)

    @property
    def empty(self):
        """ Stringify the selfue and check that it has a length. """
        if self.value is None:
            return True
        value = self.value
        if not isinstance(value, basestring):
            value = unicode(value)
        if len(value.strip()):
            return False
        return True


class TableSet(object):

    @classmethod
    def from_fileobj(cls, fileobj):
        pass

    @property
    def tables(self):
        pass


from collections import defaultdict
class RowSet(object):

    def __iter__(self):
        pass

    @property
    def typed(self):
        pass

    @property
    def headings(self):
        pass
    
    @property
    def sample_column_counts(self):
        """ Return the number of columns in the row_set's sample. """
        counts = defaultdict(int)
        for row in self.sample:
            length = len([c for c in row if not c.empty])
            counts[length] += 1
        return counts

    @property
    def sample_modal_column_count(self):
        counts = self.sample_column_counts
        if not len(counts):
            return 0
        return max(counts.items(), key=lambda (k,v): v)[0]


class CSVTableSet(TableSet):

    def __init__(self, fileobj, name=None):
        self.fileobj = fileobj
        self.name = name or 'table'

    @classmethod
    def from_fileobj(cls, fileobj, name=None):
        return cls(fileobj, name=name)

    @property
    def tables(self):
        return [(self.name, CSVRowSet(self.fileobj))]


from ilines import ilines
from itertools import chain
import csv
class CSVRowSet(RowSet):

    def __init__(self, fileobj, window=1000):
        self.fileobj = fileobj
        self.lines = ilines(fileobj)
        #self.window = window
        self._sample = []
        try:
            for i in xrange(window):
                self._sample.append(self.lines.next())
        except StopIteration:
            pass

    typed = False
    headings = False

    @property
    def sample_lines(self):
        for line in self._sample:
            yield line

    def rows(self):
        for line in chain(self.sample_lines, self.lines):
            yield line

    @property
    def dialect(self):
        sample = '\n'.join(self.sample_lines)
        return csv.Sniffer().sniff(sample)

    @property
    def sample(self):
        for row in csv.reader(self.sample_lines, dialect=self.dialect):
            yield [Cell(c) for c in row]

    def __iter__(self):
        for row in csv.reader(self.rows(), dialect=self.dialect):
            yield [Cell(c) for c in row]


from tempfile import mkstemp
from shutil import copyfileobj
import xlrd
class XLSTableSet(TableSet):

    def __init__(self, filename):
        self.workbook = xlrd.open_workbook(filename)

    @classmethod
    def from_fileobj(cls, fileobj):
        # xlrd reads from a file name, no fileobj support
        fd, name = mkstemp(suffix='xls')
        copyfileobj(fileobj, open(name, 'wb'))
        return cls(name)

    @property
    def tables(self):
        return [(name, XLSRowSet(self.workbook.sheet_by_name(name))) \
                for name in self.workbook.sheet_names()]

XLS_TYPES = {
    1: STRING, 
    2: INTEGER,
    3: DATE
    }

from itertools import islice
class XLSRowSet(RowSet):

    def __init__(self, sheet, window=1000):
        self.sheet = sheet
        self.window = window

    typed = True
    headings = False

    @property
    def sample(self):
        return islice(self, self.window)

    def __iter__(self):
        for i in xrange(self.sheet.nrows):
            row = []
            for cell in self.sheet.row(i):
                value = cell.value
                type = XLS_TYPES.get(cell.ctype, STRING)
                if type == DATE:
                    year, month, day, hour, minute, second = \
                            xlrd.xldate_as_tuple(value, self.sheet.book.datemode)
                    value = datetime(year, month, day, hour, 
                            minute, second)
                row.append(Cell(value, type=type))
            yield row

def find_header_by_count(row_set, count):
    """ Find the first row with count non-empty columns to be
    used as a header. Returns a tuple of offset and headers. """
    for i, row in enumerate(row_set.sample):
        length = len([c for c in row if not c.empty])
        if length >= count:
            return i,  [c.value for c in row]
    return 0, []

from itertools import izip_longest
def apply_headers(headers, rows):
    """ Transform the given row_set rows into ordered 
    dictionaries that contain a mapping of column name 
    to (cell_value, cell_type). If no header is defined,
    use an autogenerated name. """
    for row in rows:
        _row = []
        pairs = izip_longest(row, headers)
        for i, (cell, header) in enumerate(pairs):
            if cell is None:
                cell = Cell(None)
            cell.column = header
            if cell.column is None or not len(cell.column):
                cell.column = "column_%d" % i
                cell.column_autogenerated = True
            _row.append(cell)
        yield _row

def dictize_rowset(row_set, seek_headers=True, headers=None,
        header_offset=None, column_count=None, header_difference=1):
    """ Turn a rowset (iterator of row tuples) into an iterator
    of ordered dictionaries with named cells. 

    Parameters:
        * row_set: A row set (iterator + .sample).
        * seek_headers: Whether to search for headers in the file
          by applying some heuristics.
        * headers: pre-specifiy the header names.
        * header_offset: How many rows to skip in the head before 
          meeting the actual header. 
        * column_count: How many columns to look for on the header
          row.
        * header_difference: Maximum allowed difference between the 
          mean number of columns per row and the number of columns 
          of the header row to be selected.
    """
    if headers is not None or header_offset is not None:
        seek_headers = False
    if seek_headers:
        if header_offset is None:
            if column_count is None:
                column_count = row_set.sample_modal_column_count
            header_offset, headers = find_header_by_count(row_set, 
                    column_count-header_difference)
    if headers is None and header_offset is not None:
        headers = list(row_set.sample)[header_offset]
        headers = [c.value for c in headers]
    if headers is None:
        headers = []
    if header_offset is None:
        header_offset = 0
    content_rows = skip_n(iter(row_set), header_offset+1)
    for row in apply_headers(headers, content_rows):
        yield row



