from datetime import datetime

from messytables.util import skip_n
from messytables.ordereddict import OrderedDict
from messytables.types import type_guess
from messytables.types import StringType, IntegerType, FloatType, \
        DecimalType, DateType

class Cell(object):
    """ A cell is the basic value type. It always has a ``value`` (that
    may be ``None`` and may optionally also have a type and column name
    associated with it. """

    def __init__(self, value, column=None, type=StringType()):
        self.value = value
        self.column = column
        self.column_autogenerated = False
        self.type = type

    def __repr__(self):
        if self.column is not None:
            return "<Cell(%s=%s:%s>" % (self.column, 
                    self.type, self.value)
        return "<Cell(%r:%s>" % (self.type, self.value)

    @property
    def empty(self):
        """ Stringify the value and check that it has a length. """
        if self.value is None:
            return True
        value = self.value
        if not isinstance(value, basestring):
            value = unicode(value)
        if len(value.strip()):
            return False
        return True


class TableSet(object):
    """ A table set is used for data formats in which multiple tabular
    objects are bundeled. This might include relational databases and 
    workbooks used in spreadsheet software (Excel, LibreOffice). """

    @classmethod
    def from_fileobj(cls, fileobj):
        """ The primary way to instantiate is through a file object 
        pointer. This means you can stream a table set directly off 
        a web site or some similar source. """
        pass

    @property
    def tables(self):
        """ Return a listing of tables in the ``TableSet``. Each table
        has a name. """
        pass


from collections import defaultdict
from itertools import izip_longest
class RowSet(object):
    typed = False
    
    _column_types = None
    column_headers = None
    row_offset = None

    def set_column_types(self, types):
        self.typed = True
        self._column_types = types

    def get_column_types(self):
        return self._column_types

    column_types = property(get_column_types, set_column_types)

    def apply_types(self, row):
        """ Apply the column types set on the instance to the
        current row, attempting to cast each cell to the specified
        type. """
        if self.column_types is None:
            return row
        for cell, type in izip_longest(row, self.column_types):
            try:
                cell.value = type.cast(cell.value)
                cell.type = type
            except:
                pass
        return row

    def apply_headers(self, row):
        """ Add column names to the cells in a row_set. If no 
        header is defined, use an autogenerated name. """
        _row = []
        pairs = izip_longest(row, self.column_headers)
        for i, (cell, header) in enumerate(pairs):
            if cell is None:
                cell = Cell(None)
            cell.column = header
            if cell.column is None or not len(cell.column):
                cell.column = "column_%d" % i
                cell.column_autogenerated = True
            _row.append(cell)
        return _row

    def __iter__(self):
        """ Apply several filters to the row data. """
        rows = self.raw()
        if self.row_offset is not None:
            rows = skip_n(rows, self.row_offset)
        for row in rows:
            if self.column_types is not None:
                row = self.apply_types(row)
            if self.column_headers is not None:
                row = self.apply_headers(row)
            yield row

    def dicts(self):
        if not self.column_headers:
            raise TypeError("No column headers are defined!")
        for row in self:
            yield OrderedDict([(c.column, c.value) for c in row])

    def __repr__(self):
        return "RowSet(%s)" % self.name


class CSVTableSet(TableSet):
    """ A CSV table set. Since CSV is always just a single table,
    this is only a pass-through class. """

    def __init__(self, fileobj, name=None):
        self.fileobj = fileobj
        self.name = name or 'table'

    @classmethod
    def from_fileobj(cls, fileobj, name=None):
        return cls(fileobj, name=name)

    @property
    def tables(self):
        """ Return the actual CSV table. """
        return [CSVRowSet(self.name, self.fileobj)]


from ilines import ilines
from itertools import chain
import csv
class CSVRowSet(RowSet):

    def __init__(self, name, fileobj, window=1000):
        self.name = name
        self.fileobj = fileobj
        self.lines = ilines(fileobj)
        self._sample = []
        try:
            for i in xrange(window):
                self._sample.append(self.lines.next())
        except StopIteration:
            pass

    typed = False

    @property
    def sample_lines(self):
        for line in self._sample:
            yield line

    def rows(self):
        for line in chain(self.sample_lines, self.lines):
            yield line

    @property
    def dialect(self):
        sample = '\n'.join(self.sample_lines)
        return csv.Sniffer().sniff(sample)

    @property
    def sample(self):
        for row in csv.reader(self.sample_lines, dialect=self.dialect):
            yield self.apply_types([Cell(c) for c in row])

    def raw(self):
        for row in csv.reader(self.rows(), dialect=self.dialect):
            yield self.apply_types([Cell(c) for c in row])


from tempfile import mkstemp
from shutil import copyfileobj
import xlrd
class XLSTableSet(TableSet):

    def __init__(self, filename):
        self.workbook = xlrd.open_workbook(filename)

    @classmethod
    def from_fileobj(cls, fileobj):
        # xlrd reads from a file name, no fileobj support
        fd, name = mkstemp(suffix='xls')
        copyfileobj(fileobj, open(name, 'wb'))
        return cls(name)

    @property
    def tables(self):
        return [XLSRowSet(name, self.workbook.sheet_by_name(name)) \
                for name in self.workbook.sheet_names()]

XLS_TYPES = {
    1: StringType(), 
    2: IntegerType(),
    3: DateType(None)
    }

from itertools import islice
class XLSRowSet(RowSet):

    def __init__(self, name, sheet, window=1000):
        self.name = name
        self.sheet = sheet
        self.window = window

    typed = True

    @property
    def sample(self):
        return islice(self, self.window)

    def raw(self):
        """ Iterate over all rows in this sheet. Types are automatically
        converted according to the excel data types specified, including 
        conversion of excel dates, which are notoriously buggy. """
        for i in xrange(self.sheet.nrows):
            row = []
            for cell in self.sheet.row(i):
                value = cell.value
                type = XLS_TYPES.get(cell.ctype, StringType())
                if type == DateType(None):
                    year, month, day, hour, minute, second = \
                            xlrd.xldate_as_tuple(value, self.sheet.book.datemode)
                    value = datetime(year, month, day, hour, 
                            minute, second)
                row.append(Cell(value, type=type))
            yield row



def column_count_modal(rows):
    """ Return the modal value of columns in the row_set's 
    sample. """
    counts = defaultdict(int)
    for row in rows:
        length = len([c for c in row if not c.empty])
        counts[length] += 1
    if not len(counts):
        return 0
    return max(counts.items(), key=lambda (k,v): v)[0]


def headers_guess(rows, tolerance=1):
    """ Guess the offset and names of the headers of the row set.
    This will attempt to locate the first row within ``tolerance``
    of the mode of the number of rows in the row set sample.
    """
    rows = list(rows)
    modal = column_count_modal(rows)
    for i, row in enumerate(rows):
        length = len([c for c in row if not c.empty])
        if length >= modal - tolerance:
            # TODO: use type guessing to check that this row has
            # strings and does not conform to the type schema of 
            # the table.
            return i,  [c.value for c in row]
    return 0, []




